<!DOCTYPE html>
<meta charset="utf-8">
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
                      tex2jax: {inlineMath: [['$', '$'], ['\\(','\\)']]},
                      TeX: { equationNumbers: {autoNumber: "AMS"} },
                      "HTML-CSS": { showMathMenu: false,
                                    scale: 90 }
                     });
</script>
<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.4.2/pure-min.css">
<style>

@import url(http://fonts.googleapis.com/css?family=PT+Serif|PT+Serif:b|PT+Serif:i|PT+Sans|PT+Sans:b);
@import url(http://fonts.googleapis.com/css?family=Lato);
html {
   min-width: 1040px;
}

body {
   background: #fcfcfa;
   color: #333;
   font-family: "PT Serif", serif;
   /*margin: 0 1em 4em auto;*/
   position: relative;
   width: 960px;
   left: 13em;
}

h1, h2, h3, h4 { font-family: "Lato", "PT Serif", serif; color: #000; text-rendering: optimizeLegibility; }

h1 {
  font-size: 64px;
  line-height: 73px;
  font-weight: 900;
  margin-top: 0.67em;
  margin-right: 0;
  margin-bottom: 0;
  margin-left: 0;
}

h2 {
   margin-top: 2em;
}

subtitle {
   display:block;
   font-family: "PT Serif", serif;
   font-size: 32px;
   font-style: italic;
   font-weight: 100;
}

p {
  line-height: 150%;
  width: 720px;
}

a {
  color: steelblue;
  cursor: auto;
}

a:not(:hover) {
   text-decoration: none;
}

pre {
   border-left: solid 2px #ccc;
   padding-left: 18px;
   margin: 2em 0 2em -20px;
}

aside {
   font-size: small;
   right: 0;
   position: absolute;
   width: 180px;
}

#nav {
        left: 5px;
        font-family: "Lato", serif;
        font-weight: 700;
        list-style: none;
        margin: 0;
        position: fixed;
        top: 10px;
        box-sizing: border-box;
}


#nav li {
        margin-bottom: 0px;
}

#nav a {
        color: #333;
        display: block;
        font-size: 14px;
        border-left: 3px solid #fcfcfa;
        padding: 5px 10px;
        text-decoration: none;
}

#nav a:hover {
   border-left: 3px solid steelblue;
}

#nav .current a {
   border-left: 3px solid steelblue;
}


.client {
  fill: white;
  stroke: black;
  stroke-width: 1;
}

.site {
  fill: black;
  opacity: 0;
}

.c0 { fill: blue; stroke: #000099 }
.c1 { fill: green; stroke: #006600 }
.c2 { fill: red; stroke: #990000}
.c3 { fill: yellow; stroke: #999900 }
.c4 { fill: gray; stroke: #404040 }

.v0 { fill: blue; }
.v1 { fill: green; }
.v2 { fill: red; }
.v3 { fill: yellow; }
.v4 { fill: gray; }

.place,
.place-label {
  fill: black;
  opacity: 1;
}

text {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 15px;
  font-weight: 400;
  pointer-events: none;
}

</style>
<body>
  <ul id="nav">
    <li class="current"><a href="#intro">Intro</a></li>
    <li><a href="#problem">Problem</a></li>
    <li><a href="#model">Model</a></li>
    <li><a href="#implementation">Implementation</a></li>
    <li><a href="#demo">Live Demo</a></li>
  </ul>
  <div id="container">
    <div class="section" id="intro">
      <h1>Facility Location</h1>
        <subtitle>with integer programming and Gurobi</subtitle>
    </div>
    <p>
      In this example we'll solve a simple facility location problem:
      where to build warehouses to supply a large number of supermarkets.
    </p>

    <p>
      We'll construct a mathematical model of the business problem,
      implement this model in Gurobi's Python interface, and compute and
      visualize an optimal solution.
    </p>

    <p>
      Although your own business may not involve supermarkets, the
      same basic techniques used in this example can be used for many
      other applications in supply chain, logistics and transportation.
    </p>

    <div class="section" id="problem">
      <h2><a href="#problem" name="problem">Problem Description</a></h2>

    <div style="float:right;">
      <a href="https://en.wikipedia.org/wiki/Logistics">
        <img src="warehouse.jpg" alt="Warehouse" style="width:200px;">
      </a>
    </div>

    <p>
      A large supermarket chain needs to build warehouses for a set of
      supermarkets it is opening. The locations of the supermarkets
      have been decided, but the locations of the warehouses are yet
      to be chosen.
    </p>

    <p>
      Several good candidate locations for the warehouses have been
      determined, but it remains to decide how many warehouses to
      open and at which candidate locations to build them.
    </p>

    <p>
      Opening many warehouses would be advantageous as this would
      reduce the average distance a truck has to drive from
      warehouse to supermarket, and hence reduce the delivery cost.
      Opening a warehouse is, however, costly. We therefore have a
      tradeoff between the delivery cost and the building cost.
    </p>

    <p>
      We will use Gurobi to find the optimal tradeoff between delivery
      cost and the cost of building new facilities.
    </p>

    </div>
    <div class="section" id="model">
      <h2><a href="#model" name="model">Mathematical Model</a></h2>

      <p>
        Our example is an instance of the
        <a href="http://www.sciencedirect.com/science/article/pii/S0377221703008191">
        Uncapacitated Facility Location Problem</a>. There are many
        different types of facility location problems, see for example
        the book <a href="http://www.springer.com/us/book/9783540421726">
        Facility Location: Applications and Theory</a> for more details.
      </p>

      <p>
        Let us now formulate a mathematical model for our problem.
        Let $I$ be the set of supermarket (or <em>customer</em>) locations.
        Let $J$ be the set of candidate warehouse (or <em>facility</em>)
        locations. The goal is to choose which of the points in $J$ should
        be used to construct a facility. Therefore, for each location we
        define a binary variable $x_j$
        \[
        x_j = \left\{\begin{array}{ll}
               1 & \text{if we locate facility at candidate site $j \in J$ }\\
               0 & \mathrm{otherwise}
              \end{array}\right.
        \]
      </p>

      <p>
        There is a cost associated with constructing each warehouse. We
        denote this fixed charge by $f_j$.
      </p>

      <p>
        We denote by $c_{ij}$ the cost of shipping between candidate
        warehouse site $j$ and supermarket location $i$. The fraction
        of supply received by customer $i$ from facility $j$ is denoted
        by $y_{ij}$. This quantity has to be positive, so we have the
        constraint $y_{ij} \geq 0$. We wish to minimize the total cost,
        i.e. the sum of the cost of opening facilities and the cost
        related to shipping between facilities and clients.
        So the total cost is:
        \[
        \text{total cost} = \sum_{j \in J} f_j x_j + \sum_{j \in J} \sum_{i \in I} c_{ij} y_{ij}
        \]
      </p>

      <p>
        We can simplify the expression for total cost. $c_{ij}$ is usually
        proportional to the distance $d_{ij}$ between the facility and the
        customer, i.e. $c_{ij} = \alpha d_{ij}$, so we can replace
        $c_{ij}$ with $d_{ij}$ (which we take to be the euclidean distance
        between customer $i$ and facility $j$) and absorb the constant
        $\alpha$ into $f_j$ (by scaling $f_j$ by $1 / \alpha$).
      </p>

      <p>
        Finally, we need to add 2 constraints. Firstly, the demand for each
        customer must be supported, i.e. the sum of the fraction received
        from each facility for client $i$ must be equal to 1
        \[
        \sum_{j \in J} y_{ij} = 1 \quad \forall i \in I
        \]
        Secondly, we can only ship from facility $j$ if the facility has
        actually been built. So we have the following constraint
        \[
        y_{ij} \leq x_{ij} \quad \forall i \in I \quad \forall j \in J
        \]
      </p>

      <p>
        We end up with the following problem in the variables $x_j$ and $y_{ij}$
        \[
        \begin{array}{ll}
        \text{minimize} & \sum_{j \in J} f_j x_j + \sum_{j \in J} \sum_{i \in I} d_{ij} y_{ij} \\
        \text{subject to} & \sum_{j \in J} y_{ij} = 1 \\
                          & y_{ij} \leq x_{ij}  \\
                          & y_{ij} \geq 0  \\
                          & x_j \in \{ 0, 1 \}
        \end{array}
        \]
      </p>

    </div>
    <div class="section" id="implementation">
      <h2><a href="#implementation" name="implementation">Implementation</a></h2>
      <p>Below is the full implementation of the model (and the associated data) in
        Gurobi's Python interface:
      </p>
      <pre>
      from gurobipy import *
      import math

      def distance(a,b):
        dx = a[0] - b[0]
        dy = a[1] - b[1]
        return math.sqrt(dx*dx + dy*dy)

      # Problem data
      clients = [[0, 1.5],[2.5, 1.2]]
      facilities = [[0,0],[0,1],[0,1]
                    [1,0],[1,1],[1,2]
                    [2,0],[2,1],[2,2]]
      charge = [3,2,3,1,3,3,4,3,2]

      numFacilities = len(facilities)

      numClients = len(clients)

      m = Model()

      # Add variables
      x = {}
      y = {}
      d = {} # Distance matrix (not a variable)

      for j in range(numFacilities):
          x[j] = m.addVar(vtype=GRB.BINARY, name="x%d" % j)

      for i in range(numClients):
          for j in range(numFacilities):
              y[(i,j)] = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name="t%d,%d" % (i,j))
              d[(i,j)] = distance(clients[i], facilities[j])

      m.update()

      # Add constraints
      for i in range(numClients):
          for j in range(numFacilities):
              m.addConstr(y[(i,j)] <= x[j])

      for i in range(numClients):
          m.addConstr(quicksum(y[(i,j)] for j in range(numFacilities)) == 1)

      m.setObjective( quicksum( charge[j]*x[j] + quicksum(d[(i,j)]*y[(i,j)] for i in range(numClients)) for j in range(numFacilities) ), GRB.MINIMIZE)

      m.optimize()
      </pre>
    </div>
    <div class="section" id="demo">
      <h2><a href="#demo" name="demo">Live Demo</a></h2>

      <p>
        Below is a visualization of our example for a supermarket company
        operating in Arkansas and the surrounding states.
      </p>

      <p>
        Supermarkets are represented by:
        <svg height="20" width="20">
	  <circle cx="10" cy="15" r="3" stroke="black" stroke-width="1" fill="white" />
	</svg>
      </p>

      <p>
        Warehouses are represented by:
        <svg height="20" width="100">
	  <circle cx="10" cy="10" r="8" stroke="#000099" stroke-width="3" fill="blue" />
          <circle cx="30" cy="10" r="8" stroke="#006600" stroke-width="3" fill="green" />
          <circle cx="50" cy="10" r="8" stroke="#990000" stroke-width="3" fill="red" />
          <circle cx="70" cy="10" r="8" stroke="#999900" stroke-width="3" fill="yellow" />
          <circle cx="90" cy="10" r="8" stroke="#404040" stroke-width="3" fill="gray" />
	</svg>
      </p>

      <p>
        Click "Compute Warehouse Locations" to find the optimal locations
        using Gurobi. Every supermarket included in a colored area will be
        served by the warehouse of the same color.
      </p>

      <p>
        A few supermarket locations have already been set up, but you can add
        more by clicking the screen.
      </p>

      <div id="demoarea">
      </div>
      <button class="pure-button" onclick="compute()">Compute Warehouse Locations</button>
    </div>

    <div style="min-height:100px"></div>

<!--[if gt IE 8]><!--><script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script><!--<![endif]-->
<script src="http://davist11.github.io/jQuery-One-Page-Nav/jquery.nav.js"></script>
<script>
  $(document).ready(function() {
  console.log('calling onePageNav');
  $('#nav').onePageNav();
  });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script>

//Width and height
var width = 800;
var height = 500;
var padding = 30;

var svg = d3.select("#demoarea")
              .append("svg")
              .attr("width", width)
              .attr("height", height)
              .on("mousedown", addPoint);

// Initial points
var vertices = [[427, 269.5], [434, 271.5], [431, 278.5], [459, 321.5],
                [462, 327.5], [570, 169.5], [585, 112.5], [612, 167.5],
                [361, 307.5], [266, 134.5], [258, 134.5], [505, 226.5],
                [500, 268.5], [486, 320.5], [532, 330.5], [506, 374.5],
                [576, 374.5], [575, 444.5], [673, 343.5], [673, 426.5],
                [628, 461.5], [486, 487.5]];

// Potential sites for facilities
var sites = [];
var n = 10;
var cost = 300;
for (var i = 1; i < n; i++) {
  for (var j = 1; j < n; j++) {
    sites.push([width*i/n, height*j/n]);
  }
}

var charge = d3.range(sites.length).map(function(d) { return cost; });

// G object for map
var mapG = svg.append("g");

// G object for animations
var animationG = svg.append("g");

// G object for sites
var sitesG = svg.append("g");

// G object for points
var circleG = svg.append("g");

// G object for voronoi
var pathG = svg.append("g");

// G object for facilities
var facilitiesG = svg.append("g");

// G object for location names
var locationG = svg.append("g");

circleG.selectAll("circle")
       .data(vertices)
       .enter()
       .append("circle")
       .attr("cx", function(d) { return d[0]; })
       .attr("cy", function(d) { return d[1]; })
       .attr("class", "client")
       .attr("r", 2);

sitesG.selectAll("circle")
       .data(sites)
       .enter()
       .append("circle")
       .attr("cx", function(d) { return d[0]; })
       .attr("cy", function(d) { return d[1]; })
       .attr("class", "site")
       .attr("r", 3);

// Add the map
var projection = d3.geo.albers()
    .center([0, 35])
    .rotate([93.5, 0])
    .parallels([50, 60])
    .scale(6000)
    .translate([2*width / 5 , 0.5*height]);

var path = d3.geo.path()
    .projection(projection)
    .pointRadius(2);

// Create color gradient for the map
var mapColors = [];
var maxRed = 222, minRed = 49;
var maxGreen = 235, minGreen = 130;
var maxBlue = 247, minBlue = 189;
var numColors = 10;
for (var i = 0; i < numColors; i++) {
  var red = String( Math.round( minRed + (maxRed - minRed)*i/numColors ) );
  var green = String( Math.round( minGreen + (maxGreen - minGreen)*i/numColors) );
  var blue = String( Math.round( minBlue + (maxBlue - minBlue)*i/numColors ) );
  mapColors.push( "rgb(" + red + "," + green + "," + blue + ")");
}
console.log(mapColors);

d3.json("USwithUrban.json", function(error, us) {
  var subunits = topojson.feature(us, us.objects.statesUSA),
      places = topojson.feature(us, us.objects.placesUSA),
      urban = topojson.feature(us, us.objects.urban);

  mapG.selectAll(".subunit")
      .data(subunits.features)
      .enter().append("path")
      .attr("fill", function(d,i) { return mapColors[i % 9];})
      .attr("stroke", "white")
      .attr("stroke-width", 1)
      .attr("opacity", .8)
      .attr("d", path);

  mapG.append("path")
      .datum(urban)
      .attr("d", path)
      .attr("fill", "black")
      .attr("opacity", .1);

  locationG.append("path")
      .datum(places)
      .attr("d", path)
      .attr("class", "place");

  locationG.selectAll(".place-label")
      .data(places.features)
      .enter().append("text")
      .attr("class", "place-label")
      .attr("transform", function(d) { return "translate(" + projection(d.geometry.coordinates) + ")"; })
      .attr("x", function(d) { return d.geometry.coordinates[0] > -1 ? 6 : -6; })
      .attr("dy", ".35em")
      .style("text-anchor", function(d) { return d.geometry.coordinates[0] > -1 ? "start" : "end"; })
      .text(function(d) { return d.properties.name; });
});


function addPoint() {
  var point = d3.mouse(this);
  vertices.push(point);
  circleG.append("circle")
         .attr("cx", point[0])
         .attr("cy", point[1])
         .attr("class", "client")
         .attr("r", 2);

  // Add animation
  animationG.selectAll("circle").remove("circle");
  var anim = animationG.append("circle")
                        .attr("cx", point[0])
                        .attr("cy", point[1])
                        .attr("r", 0)
                        .attr("fill", "black");

  anim.style("opacity", .5)
      .transition()
      .style("opacity", 0)
      .attr("r", 20)
      .duration(200)
      .ease("out");

  console.log('vertices', vertices);
}

// Function that actually joins the different points of polygon
function polygon(d) {
  return "M" + d.join("L") + "Z";
}

function compute() {
  d3.json('/voronoi')
    .header('Content-Type', 'application/json')
    .post(JSON.stringify({'clients': vertices,
                          'facilities': sites,
                          'charge': charge }), serverResponse);
}

function serverResponse(error, data) {
   console.log('serverResponse');
   console.log('data', data);
   if (!error) {
      if ('solution' in data) {
          // Import solution and put it into correct format
          var solution = data['solution'];

          var facilities = [];

          for (var i = 0; i < solution.length; i++) {
            facilities.push(sites[solution[i]]);
          }

          facilitiesG.selectAll("circle").remove("circle");
          animationG.selectAll("circle").remove("circle");

          var faci = facilitiesG.selectAll("circle")
                     .data(facilities)
                     .enter()
                     .append("circle")
                     .attr("cx", function(d) { return d[0]; })
                     .attr("cy", function(d) { return d[1]; })
                     .attr("class", function(d, i) { return "c" + i % 5; })
                     .attr("r",60)
                     .attr("stroke-width", 2);

          var anim = animationG.selectAll("circle")
                     .data(facilities)
                     .enter()
                     .append("circle")
                     .attr("cx", function(d) { return d[0]; })
                     .attr("cy", function(d) { return d[1]; })
                     .attr("class", function(d, i) { return "c" + i % 5; })
                     .attr("r",0)
                     .attr("stroke-width", 0);

          faci.style("opacity", 0)
              .style("stroke-opacity", 0)
              .transition()
              .style("opacity", 1)
              .style("stroke-opacity", 1)
              .attr("r", 6)
              .duration(500)
              .delay(function(d, i) { return i*100 });

          anim.style("opacity", .5)
              .style("stroke-opacity", .5)
              .transition()
              .style("opacity", 0)
              .style("stroke-opacity", 0)
              .attr("r", 30)
              .duration(500)
              .ease("out")
              .delay(function(d, i) { return i*100 + 300});

          pathG.selectAll("path").remove("path");

          var voroPath = pathG.selectAll("path")
                              .data(d3.geom.voronoi(facilities))
                              .enter()
                              .append("path")
                              .attr("d", polygon)
                              .attr("class", function(d, i) { return "v" + i % 5; })
                              .attr("stroke-opacity", 0);

          voroPath.style("opacity", 0)
                  .transition()
                  .style("opacity", .5)
                  .duration(1000)
                  .delay(1000);
        }
      }
}

</script>
